<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pinyin & Characters Dominoes Game</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Fredoka for general text and Noto Serif SC for Chinese characters -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300..700&display=swap" rel="stylesheet">
    <style>
        /* Define custom styles here */
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #f3e8ff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
        }
        .chinese-font {
            font-family: 'Noto Serif SC', 'Kaiti', 'STKaiti', sans-serif;
        }
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in { animation: fade-in 0.5s ease-in-out; }
        @keyframes bounce-in {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-bounce-in { animation: bounce-in 0.5s ease-out; }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .animate-shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both; }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React and ReactDOM CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <!-- Babel CDN for JSX support -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback } = React;
        const { createRoot } = ReactDOM;

        // The entire application is contained within this single file.
        // All components, types, constants, and utility functions are defined here.

        // --- Types and Constants ---

        const GameState = {
            Intro: "intro",
            Playing: "playing",
            End: "end",
        };

        const TOTAL_QUESTIONS = 10;

        const GAME_DATA = [
            { pinyin: "ma", onset: "m", rime: "a", tone: 1, character: "Â¶à", distractors: ["mo", "na"], characterDistractors: ["È©¨", "Âêó"] },
            { pinyin: "wo", onset: "w", rime: "o", tone: 3, character: "Êàë", distractors: ["ou", "uo"], characterDistractors: ["‰∫∫", "‰∏™"] },
            { pinyin: "ni", onset: "n", rime: "i", tone: 3, character: "‰Ω†", distractors: ["in", "mi"], characterDistractors: ["‰ª¨", "Â•Ω"] },
            { pinyin: "hao", onset: "h", rime: "ao", tone: 3, character: "Â•Ω", distractors: ["ha", "o"], characterDistractors: ["Â•≥", "Â≠ê"] },
            { pinyin: "ba", onset: "b", rime: "a", tone: 4, character: "Áà∏", distractors: ["bo", "bu"], characterDistractors: ["Áà∂", "Â∑¥"] },
            { pinyin: "lao", onset: "l", rime: "ao", tone: 3, character: "ËÄÅ", distractors: ["lo", "ou"], characterDistractors: ["ËÄÉ", "ËÄÖ"] },
            { pinyin: "shui", onset: "sh", rime: "ui", tone: 3, character: "Ê∞¥", distractors: ["she", "uai"], characterDistractors: ["Ê∞∏", "Ê±Ç"] },
            { pinyin: "xue", onset: "x", rime: "ue", tone: 2, character: "Â≠¶", distractors: ["xu", "e"], characterDistractors: ["Â≠ó", "Áîü"] },
            { pinyin: "shang", onset: "sh", rime: "ang", tone: 4, character: "‰∏ä", distractors: ["sha", "ng"], characterDistractors: ["‰∏ã", "‰∏™"] },
            { pinyin: "xia", onset: "x", rime: "ia", tone: 4, character: "‰∏ã", distractors: ["‰∏ä", "Â§©"] },
            { pinyin: "guo", onset: "g", rime: "uo", tone: 2, character: "ÂõΩ", distractors: ["gu", "o"], characterDistractors: ["ÂÆ∂", "‰∏≠"] },
            { pinyin: "hua", onset: "h", rime: "ua", tone: 2, character: "Ëä±", distractors: ["hu", "a"], characterDistractors: ["Ëå∂", "ÂºÄ"] },
            { pinyin: "ri", onset: "r", rime: "i", tone: 4, character: "Êó•", distractors: ["re", "ru"], characterDistractors: ["Êúà", "Êòé"] },
            { pinyin: "che", onset: "ch", rime: "e", tone: 1, character: "ËΩ¶", distractors: ["ce", "he"], characterDistractors: ["‰∏ú", "Áâõ"] },
        ];

        // --- Utility Functions ---

        const shuffleArray = (array) => {
            return [...array].sort(() => Math.random() - 0.5);
        };

        const getTonedPinyin = (pinyin, tone) => {
            if (tone === null || tone === 0) return pinyin;
            const vowels = {
                'a': ['ƒÅ', '√°', '«é', '√†'], 'e': ['ƒì', '√©', 'ƒõ', '√®'],
                'o': ['≈ç', '√≥', '«í', '√≤'], 'i': ['ƒ´', '√≠', '«ê', '√¨'],
                'u': ['≈´', '√∫', '«î', '√π'], '√º': ['«ñ', '«ò', '«ö', '«ú']
            };
            let toned = pinyin;
            const toneIndex = tone - 1;
            if (pinyin.includes('a')) toned = pinyin.replace('a', vowels['a'][toneIndex]);
            else if (pinyin.includes('o')) toned = pinyin.replace('o', vowels['o'][toneIndex]);
            else if (pinyin.includes('e')) toned = pinyin.replace('e', vowels['e'][toneIndex]);
            else if (pinyin.includes('iu')) toned = pinyin.replace('u', vowels['u'][toneIndex]);
            else if (pinyin.includes('ui')) toned = pinyin.replace('i', vowels['i'][toneIndex]);
            else if (toned.includes('i')) toned = toned.replace('i', vowels['i'][toneIndex]);
            else if (toned.includes('u')) toned = toned.replace('u', vowels['u'][toneIndex]);
            else if (toned.includes('√º')) toned = toned.replace('√º', vowels['√º'][toneIndex]);
            return toned;
        };

        // --- Audio and Haptic Feedback Utilities ---

        let audioCtx = null;
        const playFeedbackSound = (isCorrect) => {
            if (typeof window === 'undefined' || !window.AudioContext) return;
            if (!audioCtx) {
                try {
                    audioCtx = new window.AudioContext();
                } catch (e) {
                    console.error("Could not create AudioContext", e);
                    return;
                }
            }
            
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;

            if (isCorrect) {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(600, now);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, now + 0.3);
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            } else {
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(150, now);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.00001, now + 0.4);
                oscillator.start(now);
                oscillator.stop(now + 0.4);
            }
        };

        const triggerHaptics = (isCorrect) => {
            if (navigator.vibrate) {
                if (isCorrect) {
                    navigator.vibrate(100); // Short buzz for correct
                } else {
                    navigator.vibrate([150, 50, 150]); // Double buzz for incorrect
                }
            }
        };

        // --- UI Components ---

        const IntroScreen = ({ onStart }) => {
            const [name, setName] = useState('');
            const [error, setError] = useState(false);

            const handleStart = () => {
                if (name.trim()) {
                    onStart(name.trim());
                } else {
                    setError(true);
                    setTimeout(() => setError(false), 500);
                }
            };

            return (
                <div className="flex flex-col items-center space-y-4 animate-fade-in">
                    <p className="text-gray-600 mb-4">Enter your name to start!</p>
                    <input
                        type="text"
                        value={name}
                        onChange={(e) => setName(e.target.value)}
                        onKeyDown={(e) => e.key === 'Enter' && handleStart()}
                        placeholder={error ? 'Please enter your name!' : 'Your name'}
                        className={`border-2 rounded-full px-5 py-3 w-full max-w-sm text-center focus:outline-none focus:ring-4 transition-all mb-4 text-gray-700 ${error ? 'border-red-500 animate-shake' : 'border-purple-300 focus:ring-purple-200'}`}
                    />
                    <button
                        onClick={handleStart}
                        className="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-8 py-3 rounded-full font-bold text-lg shadow-xl hover:shadow-2xl hover:scale-105 transform transition-all"
                    >
                        Let's go! üöÄ
                    </button>
                </div>
            );
        };


        const GameUI = ({ playerName, onGameEnd }) => {
            const [score, setScore] = useState(0);
            const [questions, setQuestions] = useState([]);
            const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
            const [currentStep, setCurrentStep] = useState(1);
            const [answers, setAnswers] = useState({ onset: null, rime: null, tone: null, character: null });
            const [feedback, setFeedback] = useState(null);
            const [animate, setAnimate] = useState(null);

            const currentWord = useMemo(() => questions[currentQuestionIndex], [questions, currentQuestionIndex]);

            useEffect(() => {
                setQuestions(shuffleArray(GAME_DATA).slice(0, TOTAL_QUESTIONS));
            }, []);

            const triggerAnimation = (target, type) => {
                setAnimate({ target, type });
                setTimeout(() => setAnimate(null), 500);
            };

            const handleNextQuestion = useCallback(() => {
                if (currentQuestionIndex + 1 >= TOTAL_QUESTIONS) {
                    onGameEnd(score);
                } else {
                    setCurrentQuestionIndex(prev => prev + 1);
                    setCurrentStep(1);
                    setAnswers({ onset: null, rime: null, tone: null, character: null });
                    setFeedback(null);
                }
            }, [currentQuestionIndex, score, onGameEnd]);

            const playCurrentWordAudio = useCallback(() => {
                if (!currentWord) return;
                if (!('speechSynthesis' in window)) {
                    console.error("Speech Synthesis not supported");
                    alert("Sorry, your browser does not support the audio playback feature.");
                    return;
                }
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(currentWord.character);
                utterance.lang = 'zh-CN';
                utterance.rate = 0.85;
                window.speechSynthesis.speak(utterance);
            }, [currentWord]);

            const handleStep1Drop = (type, value) => {
                const isCorrect = currentWord && value === currentWord[type];
                playFeedbackSound(isCorrect);
                triggerHaptics(isCorrect);
            
                if (isCorrect) {
                    const newAnswers = { ...answers, [type]: value };
                    setAnswers(newAnswers);
                    triggerAnimation(`drop-zone-${type}`, 'bounce');
                    
                    const otherType = type === 'onset' ? 'rime' : 'onset';
                    if (newAnswers[otherType]) {
                        setFeedback({ message: 'Perfect! Onset and rime match.', color: 'green' });
                    } else {
                        setFeedback({ message: `Correct ${type}! Now find the ${otherType}.`, color: 'green' });
                    }
                } else {
                    setFeedback({ message: `That's not the right ${type}. Try another tile.`, color: 'red' });
                    triggerAnimation(`drop-zone-${type}`, 'shake');
                }
            };
            
            const handleToneSelect = (tone) => {
                const isCorrect = tone === currentWord.tone;
                playFeedbackSound(isCorrect);
                triggerHaptics(isCorrect);
                setAnswers(prev => ({ ...prev, tone }));
            
                if (isCorrect) {
                    setFeedback({ message: 'That\'s the right tone! Now for the character.', color: 'green' });
                    triggerAnimation(`tone-${tone}`, 'bounce');
                } else {
                    setFeedback({ message: `Not the correct tone for '${currentWord.pinyin}'. Try again.`, color: 'red' });
                    triggerAnimation(`tone-${tone}`, 'shake');
                }
            };
            
            const handleCharacterSelect = (char) => {
                const isCorrect = char === currentWord.character;
                playFeedbackSound(isCorrect);
                triggerHaptics(isCorrect);

                if(isCorrect) {
                    setAnswers(prev => ({...prev, character: char}));
                    setFeedback({ message: `You got it! This is "${char}". Great job! üéâ`, color: 'green' });
                    setScore(s => s + 1);
                    triggerAnimation(`char-${char}`, 'bounce');
                } else {
                    setFeedback({ message: 'Not quite. That character is pronounced differently.', color: 'red' });
                    triggerAnimation(`char-${char}`, 'shake');
                }
            }
            
            const showNextStepButton = (currentStep === 1 && answers.onset && answers.rime) || (currentStep === 2 && answers.tone === currentWord.tone);
            
            if (!currentWord) {
                return <div className="flex justify-center items-center p-8"><Spinner /></div>;
            }

            return (
                <div className="w-full flex flex-col items-center animate-fade-in">
                    <div className="flex justify-between w-full text-md text-gray-600 mb-4">
                        <div className="font-semibold text-gray-700">Player: {playerName}</div>
                        <div className="font-semibold text-gray-700">Score: {score}</div>
                    </div>
                    <div className="text-sm font-medium text-gray-500 mb-4">
                        Question {currentQuestionIndex + 1} of {TOTAL_QUESTIONS}
                    </div>

                    <div className="w-full">
                        {currentStep === 1 && <Step1 word={currentWord} answers={answers} onDrop={handleStep1Drop} onPlayCurrentWordAudio={playCurrentWordAudio} animate={animate} />}
                        {currentStep === 2 && <Step2 word={currentWord} answers={answers} onToneSelect={handleToneSelect} onPlayCurrentWordAudio={playCurrentWordAudio} animate={animate} />}
                        {currentStep === 3 && <Step3 word={currentWord} onCharacterSelect={handleCharacterSelect} animate={animate} onPlayCurrentWordAudio={playCurrentWordAudio} />}
                    </div>
                    
                    <div className="mt-8 text-center h-16">
                        {feedback && (
                            <p className={`text-xl font-semibold ${feedback.color === 'green' ? 'text-green-600' : 'text-red-600'}`}>{feedback.message}</p>
                        )}
                        <div className="flex justify-center space-x-4 mt-4">
                            {answers.character && <button onClick={handleNextQuestion} className="bg-gradient-to-r from-green-500 to-green-700 text-white px-6 py-2 rounded-full font-bold shadow-lg hover:shadow-xl hover:scale-105 transform transition-all">Next Question</button>}
                            {showNextStepButton && <button onClick={() => { setCurrentStep(s => s + 1); setFeedback(null); }} className="bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-6 py-2 rounded-full font-bold shadow-lg hover:shadow-xl hover:scale-105 transform transition-all">Next Step</button>}
                        </div>
                    </div>
                    
                    <div className="mt-4 flex justify-center space-x-4">
                        {currentStep > 1 && <button onClick={() => setCurrentStep(s => s - 1)} className="bg-gray-300 text-gray-700 px-6 py-2 rounded-full font-bold shadow-md hover:bg-gray-400 hover:scale-105 transform transition-all">Previous Step</button>}
                        <button onClick={handleNextQuestion} className="bg-gradient-to-r from-yellow-400 to-orange-500 text-white px-6 py-2 rounded-full font-bold shadow-lg hover:shadow-xl hover:scale-105 transform transition-all">Skip ‚è≠Ô∏è</button>
                    </div>
                </div>
            );
        };

        const Step1 = ({ word, answers, onDrop, onPlayCurrentWordAudio, animate }) => {
            const tiles = useMemo(() => shuffleArray([word.onset, word.rime, ...word.distractors]), [word]);
            const [dragOverZone, setDragOverZone] = useState(null);

            const handleDragStart = (e, value) => {
                e.dataTransfer.setData('text/plain', value);
            };
            
            return (
                <div className="space-y-6">
                    <h2 className="text-2xl font-semibold text-gray-700 text-center">Step 1: Onset & Rime</h2>
                    <div className="flex justify-center items-center space-x-4">
                        <h3 className="text-5xl font-extrabold text-gray-900">{word.pinyin}</h3>
                        <button onClick={onPlayCurrentWordAudio} className="p-4 bg-purple-200 rounded-full hover:bg-purple-300 transform scale-100 hover:scale-110 transition-transform"><AudioIcon /></button>
                    </div>
                    <div className="flex flex-wrap justify-center gap-4 mt-8">
                        {tiles.map((tile) => {
                            const isUsed = tile === answers.onset || tile === answers.rime;
                            return (
                                <div key={tile} draggable={!isUsed} onDragStart={(e) => handleDragStart(e, tile)} className={`domino-tile bg-gradient-to-r from-teal-400 to-cyan-500 text-white p-6 rounded-xl shadow-lg text-2xl font-bold min-w-[4rem] text-center ${isUsed ? 'opacity-30' : 'cursor-grab hover:shadow-xl hover:-translate-y-1 transition-all'}`}>{tile}</div>
                            );
                        })}
                    </div>
                    <div className="flex flex-col md:flex-row justify-center space-y-4 md:space-y-0 md:space-x-4 mt-8">
                        {(['onset', 'rime']).map(type => (
                            <div key={type} id={`drop-zone-${type}`} onDragOver={(e) => { e.preventDefault(); setDragOverZone(type); }} onDragLeave={() => setDragOverZone(null)} onDrop={(e) => { e.preventDefault(); setDragOverZone(null); onDrop(type, e.dataTransfer.getData('text/plain')); }} className={`drop-zone flex-1 p-8 rounded-xl flex flex-col justify-center items-center border-2 border-dashed transition-all duration-300 ${dragOverZone === type ? 'bg-indigo-200 scale-105' : 'bg-indigo-100 border-indigo-300'} ${animate?.target === `drop-zone-${type}` && animate?.type === 'shake' ? 'animate-shake' : ''}`}>
                                <span className="text-gray-500 font-semibold text-sm mb-1 capitalize">{type}</span>
                                <span className={`text-3xl font-bold text-gray-900 ${animate?.target === `drop-zone-${type}` && animate?.type === 'bounce' ? 'animate-bounce-in' : ''}`}>{answers[type] || '?'}</span>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const Step2 = ({ word, answers, onToneSelect, onPlayCurrentWordAudio, animate }) => (
            <div className="space-y-6">
                <h2 className="text-2xl font-semibold text-gray-700 text-center">Step 2: Select the Tone</h2>
                <div className="flex flex-col items-center space-y-4">
                    <p className="text-5xl font-bold text-gray-800">{getTonedPinyin(word.pinyin, answers.tone)}</p>
                    <button onClick={onPlayCurrentWordAudio} className="p-4 bg-purple-200 rounded-full hover:bg-purple-300 transform scale-100 hover:scale-110 transition-transform"><AudioIcon /></button>
                    <div className="flex flex-wrap justify-center gap-4 mt-4">
                        {[1, 2, 3, 4].map(tone => (
                            <button key={tone} id={`tone-${tone}`} onClick={() => onToneSelect(tone)} className={`tone-button bg-white text-gray-800 px-6 py-3 rounded-full font-bold text-lg shadow-md hover:scale-105 transform transition-all ${answers.tone === tone ? 'ring-4 ring-purple-400' : ''} ${animate?.target === `tone-${tone}` ? (animate.type === 'bounce' ? 'animate-bounce-in' : 'animate-shake') : ''}`}>{getTonedPinyin(word.pinyin, tone)}</button>
                        ))}
                    </div>
                </div>
            </div>
        );

        const Step3 = ({ word, onCharacterSelect, animate, onPlayCurrentWordAudio }) => {
            const characters = useMemo(() => shuffleArray([word.character, ...word.characterDistractors]), [word]);

            return (
                <div className="space-y-6">
                    <h2 className="text-2xl font-semibold text-gray-700 text-center">Step 3: Match the Character</h2>
                    <div className="flex justify-center items-center space-x-4">
                        <p className="text-5xl font-bold text-gray-800 text-center">{getTonedPinyin(word.pinyin, word.tone)}</p>
                        <button onClick={onPlayCurrentWordAudio} className="p-4 bg-purple-200 rounded-full hover:bg-purple-300 transform scale-100 hover:scale-110 transition-transform"><AudioIcon /></button>
                    </div>
                    <div className="flex flex-wrap justify-center gap-4 mt-4">
                        {characters.map(char => (
                            <button key={char} id={`char-${char}`} onClick={() => onCharacterSelect(char)} className={`character-button chinese-font bg-white text-gray-800 text-4xl p-6 rounded-xl shadow-md hover:bg-gray-100 hover:scale-105 transform transition-all w-24 h-24 flex items-center justify-center ${animate?.target === `char-${char}` ? (animate.type === 'bounce' ? 'animate-bounce-in' : 'animate-shake') : ''}`}>{char}</button>
                        ))}
                    </div>
                </div>
            );
        };

        const EndScreen = ({ score, onRestart }) => (
            <div className="animate-fade-in space-y-4 text-center">
                <h2 className="text-3xl font-bold text-green-600">Congratulations! üéâ</h2>
                <p className="text-gray-700 text-lg">You have completed all {TOTAL_QUESTIONS} questions.</p>
                <p className="text-gray-700 text-lg font-bold">Your final score is: {score} points!</p>
                <button onClick={onRestart} className="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-8 py-3 rounded-full font-bold text-lg shadow-xl hover:shadow-2xl hover:scale-105 transform transition-all">
                    Play Again
                </button>
            </div>
        );

        const Spinner = () => {
            return (
                <div
                    className="inline-block h-6 w-6 animate-spin rounded-full border-4 border-solid border-current border-r-transparent align-[-0.125em] text-indigo-600 motion-reduce:animate-[spin_1.5s_linear_infinite]"
                    role="status"
                >
                    <span className="!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]">
                        Loading...
                    </span>
                </div>
            );
        };

        const AudioIcon = ({ className = "h-8 w-8 text-purple-600" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                <path strokeLinecap="round" strokeLinejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.293-4.293A1 1 0 0111 5.414V14a1 1 0 01-.293.707L5.586 15z" />
            </svg>
        );


        const App = () => {
            const [gameState, setGameState] = useState(GameState.Intro);
            const [playerName, setPlayerName] = useState('');
            const [finalScore, setFinalScore] = useState(0);

            const handleStartGame = (name) => {
                setPlayerName(name);
                setGameState(GameState.Playing);
            };

            const handleGameEnd = (score) => {
                setFinalScore(score);
                setGameState(GameState.End);
            };
            
            const handleRestart = () => {
                setPlayerName('');
                setFinalScore(0);
                setGameState(GameState.Intro);
            }

            const renderContent = () => {
                switch (gameState) {
                    case GameState.Playing:
                        return <GameUI playerName={playerName} onGameEnd={handleGameEnd} />;
                    case GameState.End:
                        return <EndScreen score={finalScore} onRestart={handleRestart} />;
                    case GameState.Intro:
                    default:
                        return <IntroScreen onStart={handleStartGame} />;
                }
            };

            return (
                <div className="bg-white p-6 sm:p-10 rounded-2xl shadow-2xl max-w-2xl w-full text-center min-h-[600px] flex flex-col items-center">
                    <h1 className="text-4xl font-bold text-gray-800 mb-6 drop-shadow-sm">Pinyin & Characters Dominoes!</h1>
                    {renderContent()}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>
